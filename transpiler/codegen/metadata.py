"""
Metadata generation for Solidity to TypeScript transpilation.

This module generates factory files for dependency injection,
enabling proper instantiation of transpiled contracts with their dependencies.
"""

from typing import List, Dict, Set, Optional, Tuple
from pathlib import Path

from ..parser.ast_nodes import (
    SourceUnit,
    ContractDefinition,
    FunctionDefinition,
    VariableDeclaration,
)


class ContractMetadata:
    """Metadata about a single contract for factory generation."""

    def __init__(self, name: str, kind: str, file_path: str):
        self.name = name
        self.kind = kind  # 'contract', 'interface', 'library', 'abstract'
        self.file_path = file_path  # relative path without extension
        self.constructor_params: List[Tuple[str, str]] = []  # (name, type)
        self.base_contracts: List[str] = []
        self.is_abstract = kind == 'abstract'


class MetadataExtractor:
    """Extracts metadata from parsed Solidity ASTs."""

    def __init__(self):
        self.contracts: Dict[str, ContractMetadata] = {}
        self.interfaces: Set[str] = set()
        self.libraries: Set[str] = set()

    def extract_from_ast(self, ast: SourceUnit, file_path: str) -> None:
        """Extract metadata from a parsed AST.

        Args:
            ast: The parsed SourceUnit
            file_path: Relative file path (without .sol extension)
        """
        for contract in ast.contracts:
            metadata = ContractMetadata(
                name=contract.name,
                kind=contract.kind,
                file_path=file_path
            )

            # Track contract type
            if contract.kind == 'interface':
                self.interfaces.add(contract.name)
            elif contract.kind == 'library':
                self.libraries.add(contract.name)

            # Extract base contracts
            metadata.base_contracts = list(contract.base_contracts)

            # Extract constructor parameters
            if contract.constructor:
                metadata.constructor_params = self._extract_params(
                    contract.constructor
                )

            self.contracts[contract.name] = metadata

    def _extract_params(
        self, func: FunctionDefinition
    ) -> List[Tuple[str, str]]:
        """Extract parameter names and types from a function."""
        params = []
        for param in func.parameters:
            type_name = self._get_type_string(param)
            params.append((param.name, type_name))
        return params

    def _get_type_string(self, param: VariableDeclaration) -> str:
        """Get the type string for a parameter."""
        if param.type_name is None:
            return 'any'

        type_name = param.type_name.name or 'any'

        # Check if it's a contract/interface type (dependency)
        if type_name in self.contracts or type_name in self.interfaces:
            return type_name

        return type_name


class FactoryGenerator:
    """Generates factories.ts file for dependency injection."""

    def __init__(self, metadata: MetadataExtractor):
        self.metadata = metadata

    def generate(self) -> str:
        """Generate the factories.ts content.

        Returns:
            The TypeScript code for factories.ts
        """
        lines = [
            "// Auto-generated by sol2ts transpiler",
            "// Factory registration for dependency injection",
            "",
            "import { ContractContainer } from './runtime';",
            "",
        ]

        # Generate imports for all contracts
        imports = self._generate_imports()
        lines.extend(imports)
        lines.append("")

        # Generate the setupContainer function
        lines.append("/**")
        lines.append(" * Register all transpiled contracts with the container.")
        lines.append(" * Call this to set up dependency injection for the contracts.")
        lines.append(" */")
        lines.append("export function setupContainer(container: ContractContainer): void {")

        # Register interfaces as aliases (they resolve to implementations)
        for interface_name in sorted(self.metadata.interfaces):
            # Find implementing contract
            impl = self._find_implementation(interface_name)
            if impl:
                lines.append(f"  container.registerAlias('{interface_name}', '{impl}');")

        lines.append("")

        # Register contracts
        for name, meta in sorted(self.metadata.contracts.items()):
            if meta.kind == 'interface':
                continue
            if meta.kind == 'library':
                # Libraries are static, register as singletons
                lines.append(f"  container.registerSingleton('{name}', {name});")
            elif meta.is_abstract:
                # Abstract contracts can't be instantiated directly
                continue
            else:
                # Regular contracts - register with factory
                registration = self._generate_registration(name, meta)
                lines.append(registration)

        lines.append("}")
        lines.append("")

        return '\n'.join(lines)

    def _generate_imports(self) -> List[str]:
        """Generate import statements for all contracts."""
        imports = []

        # Group by file path
        by_path: Dict[str, List[str]] = {}
        for name, meta in self.metadata.contracts.items():
            if meta.kind == 'interface':
                continue  # Don't import interfaces
            path = meta.file_path
            if path not in by_path:
                by_path[path] = []
            by_path[path].append(name)

        # Generate imports
        for path, names in sorted(by_path.items()):
            names_str = ', '.join(sorted(names))
            # Convert path to relative import
            import_path = './' + path.replace('\\', '/')
            imports.append(f"import {{ {names_str} }} from '{import_path}';")

        return imports

    def _generate_registration(self, name: str, meta: ContractMetadata) -> str:
        """Generate container registration for a contract."""
        # Determine dependencies from constructor params
        deps = []
        for param_name, param_type in meta.constructor_params:
            # Check if param type is a contract/interface
            if param_type in self.metadata.contracts or param_type in self.metadata.interfaces:
                deps.append(param_type)

        if not deps:
            # No dependencies - simple registration
            return f"  container.registerLazySingleton('{name}', [], () => new {name}());"

        # Has dependencies
        deps_str = ', '.join(f"'{d}'" for d in deps)
        params_str = ', '.join(f'd{i}' for i in range(len(deps)))
        return (
            f"  container.registerLazySingleton('{name}', [{deps_str}], "
            f"({params_str}) => new {name}({{ {self._generate_args(meta, deps)} }}));"
        )

    def _generate_args(
        self, meta: ContractMetadata, deps: List[str]
    ) -> str:
        """Generate constructor argument mapping."""
        args = []
        dep_idx = 0
        for param_name, param_type in meta.constructor_params:
            if param_type in deps:
                args.append(f"{param_name}: d{dep_idx}")
                dep_idx += 1
            # Skip non-contract params (they need to be provided separately)
        return ', '.join(args)

    def _find_implementation(self, interface_name: str) -> Optional[str]:
        """Find a contract that implements an interface."""
        # Simple heuristic: look for contract with same name minus 'I' prefix
        if interface_name.startswith('I') and len(interface_name) > 1:
            impl_name = interface_name[1:]
            if impl_name in self.metadata.contracts:
                return impl_name

        # Look for contracts that inherit from this interface
        for name, meta in self.metadata.contracts.items():
            if interface_name in meta.base_contracts:
                if not meta.is_abstract and meta.kind == 'contract':
                    return name

        return None
