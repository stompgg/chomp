"""
Metadata generation for Solidity to TypeScript transpilation.

This module generates factory files for dependency injection,
enabling proper instantiation of transpiled contracts with their dependencies.
"""

from typing import List, Dict, Set, Optional, Tuple
from pathlib import Path

from ..parser.ast_nodes import (
    SourceUnit,
    ContractDefinition,
    FunctionDefinition,
    VariableDeclaration,
)
from ..dependency_resolver import DependencyResolver


class ContractMetadata:
    """Metadata about a single contract for factory generation."""

    def __init__(self, name: str, kind: str, file_path: str):
        self.name = name
        self.kind = kind  # 'contract', 'interface', 'library', 'abstract'
        self.file_path = file_path  # relative path without extension
        self.constructor_params: List[Tuple[str, str]] = []  # (name, type)
        self.base_contracts: List[str] = []
        self.is_abstract = kind == 'abstract'


class MetadataExtractor:
    """Extracts metadata from parsed Solidity ASTs."""

    def __init__(self):
        self.contracts: Dict[str, ContractMetadata] = {}
        self.interfaces: Set[str] = set()
        self.libraries: Set[str] = set()

    def extract_from_ast(self, ast: SourceUnit, file_path: str) -> None:
        """Extract metadata from a parsed AST.

        Args:
            ast: The parsed SourceUnit
            file_path: Relative file path (without .sol extension)
        """
        for contract in ast.contracts:
            metadata = ContractMetadata(
                name=contract.name,
                kind=contract.kind,
                file_path=file_path
            )

            # Track contract type
            if contract.kind == 'interface':
                self.interfaces.add(contract.name)
            elif contract.kind == 'library':
                self.libraries.add(contract.name)

            # Extract base contracts
            metadata.base_contracts = list(contract.base_contracts)

            # Extract constructor parameters
            if contract.constructor:
                metadata.constructor_params = self._extract_params(
                    contract.constructor
                )

            self.contracts[contract.name] = metadata

    def _extract_params(
        self, func: FunctionDefinition
    ) -> List[Tuple[str, str]]:
        """Extract parameter names and types from a function."""
        params = []
        for param in func.parameters:
            type_name = self._get_type_string(param)
            params.append((param.name, type_name))
        return params

    def _get_type_string(self, param: VariableDeclaration) -> str:
        """Get the type string for a parameter."""
        if param.type_name is None:
            return 'any'

        type_name = param.type_name.name or 'any'

        # Check if it's a contract/interface type (dependency)
        if type_name in self.contracts or type_name in self.interfaces:
            return type_name

        return type_name


class FactoryGenerator:
    """Generates factories.ts file for dependency injection."""

    def __init__(
        self,
        metadata: MetadataExtractor,
        resolver: Optional[DependencyResolver] = None
    ):
        self.metadata = metadata
        self.resolver = resolver
        # Cache resolved dependencies per contract
        self._resolved_deps: Dict[str, List[Dict]] = {}

    def generate(self) -> str:
        """Generate the factories.ts content.

        Returns:
            The TypeScript code for factories.ts
        """
        lines = [
            "// Auto-generated by sol2ts transpiler",
            "// Factory registration for dependency injection",
            "",
            "import { ContractContainer } from './runtime';",
            "",
        ]

        # Generate imports for all contracts
        imports = self._generate_imports()
        lines.extend(imports)
        lines.append("")

        # Generate contracts registry (for external use)
        contracts_registry = self._generate_contracts_registry()
        lines.extend(contracts_registry)
        lines.append("")

        # Generate interface aliases map (for external use)
        aliases_map = self._generate_interface_aliases_map()
        lines.extend(aliases_map)
        lines.append("")

        # Generate the setupContainer function
        lines.append("/**")
        lines.append(" * Register all transpiled contracts with the container.")
        lines.append(" * Call this to set up dependency injection for the contracts.")
        lines.append(" */")
        lines.append("export function setupContainer(container: ContractContainer): void {")

        # Register interfaces as aliases (they resolve to implementations)
        for interface_name in sorted(self.metadata.interfaces):
            # Find implementing contract
            impl = self._find_implementation(interface_name)
            if impl:
                lines.append(f"  container.registerAlias('{interface_name}', '{impl}');")

        lines.append("")

        # Register contracts
        for name, meta in sorted(self.metadata.contracts.items()):
            if meta.kind == 'interface':
                continue
            if meta.is_abstract:
                # Abstract contracts can't be instantiated directly
                continue
            if self._should_skip(name):
                # Skip contracts in the skip list
                continue
            if meta.kind == 'library':
                # Libraries are static, register as singletons
                lines.append(f"  container.registerSingleton('{name}', {name});")
            else:
                # Regular contracts - register with factory
                registration = self._generate_registration(name, meta)
                lines.append(registration)

        lines.append("}")
        lines.append("")

        return '\n'.join(lines)

    def _should_skip(self, name: str) -> bool:
        """Check if a contract should be skipped based on the skip list."""
        if self.resolver and name in self.resolver.skip_contracts:
            return True
        return False

    def _generate_imports(self) -> List[str]:
        """Generate import statements for all contracts."""
        imports = []

        # Group by file path, excluding abstract contracts, interfaces, and skipped contracts
        by_path: Dict[str, List[str]] = {}
        for name, meta in self.metadata.contracts.items():
            if meta.kind == 'interface':
                continue  # Don't import interfaces
            if meta.is_abstract:
                continue  # Don't import abstract contracts (can't instantiate)
            if self._should_skip(name):
                continue  # Don't import skipped contracts
            path = meta.file_path
            if path not in by_path:
                by_path[path] = []
            by_path[path].append(name)

        # Generate imports
        for path, names in sorted(by_path.items()):
            names_str = ', '.join(sorted(names))
            # Convert path to relative import
            import_path = './' + path.replace('\\', '/')
            imports.append(f"import {{ {names_str} }} from '{import_path}';")

        return imports

    def _generate_registration(self, name: str, meta: ContractMetadata) -> str:
        """Generate container registration for a contract."""
        # Determine dependencies from constructor params
        # List of (param_name, type_name, resolved_name, is_self)
        deps = []
        for idx, (param_name, param_type) in enumerate(meta.constructor_params):
            # Check if param type is a contract/interface
            is_interface = param_type in self.metadata.interfaces
            is_contract = param_type in self.metadata.contracts

            if is_contract or is_interface:
                resolved_name = param_type  # Default to type name
                is_self = False  # Whether this is a self-referential dependency

                # Use resolver if available and it's an interface
                if self.resolver and is_interface:
                    resolved_dep = self.resolver.resolve(
                        contract_name=name,
                        param_name=param_name,
                        type_name=param_type,
                        is_interface=True,
                        is_value_type=False,
                        param_index=idx,
                    )
                    if resolved_dep.resolved_as:
                        # Handle @self marker for self-referential dependencies
                        if resolved_dep.resolved_as == "@self":
                            is_self = True
                            resolved_name = None
                        # Handle both single values and arrays
                        elif isinstance(resolved_dep.resolved_as, list):
                            resolved_name = resolved_dep.resolved_as[0] if resolved_dep.resolved_as else param_type
                        else:
                            resolved_name = resolved_dep.resolved_as

                deps.append((param_name, param_type, resolved_name, is_self))

        if not deps:
            # No dependencies - simple registration
            return f"  container.registerLazySingleton('{name}', [], () => new {name}());"

        # Filter out self-referential deps from the container deps array
        container_deps = [(pn, pt, rn) for pn, pt, rn, is_self in deps if not is_self]

        if not container_deps:
            # All deps are self-referential - pass undefined for each
            args = self._generate_positional_args(meta, deps)
            return f"  container.registerLazySingleton('{name}', [], () => new {name}({args}));"

        # Has dependencies - use resolved names with positional arguments
        deps_str = ', '.join(f"'{resolved}'" for _, _, resolved in container_deps)
        params_str = ', '.join(f'd{i}' for i in range(len(container_deps)))
        args = self._generate_positional_args(meta, deps)
        return (
            f"  container.registerLazySingleton('{name}', [{deps_str}], "
            f"({params_str}) => new {name}({args}));"
        )

    def _generate_args(
        self, meta: ContractMetadata, deps: List[str]
    ) -> str:
        """Generate constructor argument mapping (legacy, for type-only deps)."""
        args = []
        dep_idx = 0
        for param_name, param_type in meta.constructor_params:
            if param_type in deps:
                args.append(f"{param_name}: d{dep_idx}")
                dep_idx += 1
            # Skip non-contract params (they need to be provided separately)
        return ', '.join(args)

    def _generate_args_resolved(
        self, meta: ContractMetadata, deps: List[Tuple[str, str, str]]
    ) -> str:
        """Generate constructor argument mapping with resolved deps."""
        args = []
        dep_names = {param_name for param_name, _, _ in deps}
        dep_idx = 0
        for param_name, _ in meta.constructor_params:
            if param_name in dep_names:
                args.append(f"{param_name}: d{dep_idx}")
                dep_idx += 1
            # Skip non-contract params (they need to be provided separately)
        return ', '.join(args)

    def _generate_positional_args(
        self, meta: ContractMetadata, deps: List[Tuple[str, str, str, bool]]
    ) -> str:
        """Generate positional constructor arguments, handling self-referential deps."""
        args = []
        # Build lookup: param_name -> is_self
        self_deps = {param_name for param_name, _, _, is_self in deps if is_self}
        non_self_deps = {param_name for param_name, _, _, is_self in deps if not is_self}
        dep_idx = 0
        for param_name, _ in meta.constructor_params:
            if param_name in self_deps:
                # Self-referential: pass undefined
                args.append("undefined")
            elif param_name in non_self_deps:
                args.append(f"d{dep_idx}")
                dep_idx += 1
            # Skip non-contract params (they need to be provided separately)
        return ', '.join(args)

    def _generate_contracts_registry(self) -> List[str]:
        """Generate the contracts registry export."""
        lines = [
            "// Contract registry: maps contract names to their class and dependencies",
            "export const contracts: Record<string, { cls: new (...args: any[]) => any; deps: string[] }> = {"
        ]

        for name, meta in sorted(self.metadata.contracts.items()):
            if meta.kind == 'interface' or meta.is_abstract:
                continue
            if self._should_skip(name):
                continue

            # Get resolved dependencies
            deps = self._get_resolved_deps(name, meta)
            deps_list = [resolved for _, _, resolved, is_self in deps if not is_self and resolved]
            deps_str = ', '.join(f"'{d}'" for d in deps_list)

            lines.append(f"  {name}: {{ cls: {name}, deps: [{deps_str}] }},")

        lines.append("};")
        return lines

    def _generate_interface_aliases_map(self) -> List[str]:
        """Generate the interface aliases map export."""
        lines = [
            "// Interface aliases: maps interface names to their implementation",
            "export const interfaceAliases: Record<string, string> = {"
        ]

        for interface_name in sorted(self.metadata.interfaces):
            impl = self._find_implementation(interface_name)
            if impl:
                lines.append(f"  {interface_name}: '{impl}',")

        lines.append("};")
        return lines

    def _get_resolved_deps(
        self, contract_name: str, meta: ContractMetadata
    ) -> List[Tuple[str, str, str, bool]]:
        """Get resolved dependencies for a contract."""
        deps = []
        for idx, (param_name, param_type) in enumerate(meta.constructor_params):
            is_interface = param_type in self.metadata.interfaces
            is_contract = param_type in self.metadata.contracts

            if is_contract or is_interface:
                resolved_name = param_type
                is_self = False

                if self.resolver and is_interface:
                    resolved_dep = self.resolver.resolve(
                        contract_name=contract_name,
                        param_name=param_name,
                        type_name=param_type,
                        is_interface=True,
                        is_value_type=False,
                        param_index=idx,
                    )
                    if resolved_dep.resolved_as:
                        if resolved_dep.resolved_as == "@self":
                            is_self = True
                            resolved_name = None
                        elif isinstance(resolved_dep.resolved_as, list):
                            resolved_name = resolved_dep.resolved_as[0] if resolved_dep.resolved_as else param_type
                        else:
                            resolved_name = resolved_dep.resolved_as

                deps.append((param_name, param_type, resolved_name, is_self))

        return deps

    def _find_implementation(self, interface_name: str) -> Optional[str]:
        """Find a non-abstract, non-skipped contract that implements an interface."""
        # Simple heuristic: look for contract with same name minus 'I' prefix
        if interface_name.startswith('I') and len(interface_name) > 1:
            impl_name = interface_name[1:]
            if impl_name in self.metadata.contracts:
                meta = self.metadata.contracts[impl_name]
                # Only return if it's not abstract and not skipped
                if not meta.is_abstract and meta.kind == 'contract' and not self._should_skip(impl_name):
                    return impl_name

        # Look for contracts that inherit from this interface
        for name, meta in self.metadata.contracts.items():
            if interface_name in meta.base_contracts:
                if not meta.is_abstract and meta.kind == 'contract' and not self._should_skip(name):
                    return name

        return None
