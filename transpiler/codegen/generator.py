"""
Main TypeScript code generator orchestrator.

This module provides the TypeScriptCodeGenerator class that orchestrates
the generation of TypeScript code from Solidity AST by coordinating
specialized generators for different AST node types.
"""

from typing import Optional, Set, Dict, List

from .context import CodeGenerationContext
from .type_converter import TypeConverter
from .expression import ExpressionGenerator
from .statement import StatementGenerator
from .function import FunctionGenerator
from .definition import DefinitionGenerator
from .imports import ImportGenerator
from .contract import ContractGenerator

from ..parser.ast_nodes import SourceUnit
from ..types import TypeRegistry


class TypeScriptCodeGenerator:
    """
    Main TypeScript code generator.

    This class orchestrates the generation of TypeScript code from Solidity AST
    by coordinating specialized generators for different concerns:
    - TypeConverter: Type conversions
    - ExpressionGenerator: Expressions
    - StatementGenerator: Statements
    - FunctionGenerator: Functions
    - DefinitionGenerator: Structs, enums, constants
    - ImportGenerator: Import statements
    - ContractGenerator: Contracts and classes

    Usage:
        generator = TypeScriptCodeGenerator(registry, file_depth=0)
        ts_code = generator.generate(ast)
    """

    def __init__(
        self,
        registry: Optional[TypeRegistry] = None,
        file_depth: int = 0,
        current_file_path: str = '',
        runtime_replacement_classes: Optional[Set[str]] = None,
        runtime_replacement_mixins: Optional[Dict[str, str]] = None,
        runtime_replacement_methods: Optional[Dict[str, Set[str]]] = None,
    ):
        """
        Initialize the code generator.

        Args:
            registry: Type registry for cross-file type information
            file_depth: Depth of output file for relative imports
            current_file_path: Relative path of current file (without extension)
            runtime_replacement_classes: Classes to import from runtime
            runtime_replacement_mixins: Mixin code for secondary inheritance
            runtime_replacement_methods: Method names for override detection
        """
        # Create context
        self._ctx = CodeGenerationContext.from_registry(
            registry,
            file_depth=file_depth,
            current_file_path=current_file_path,
            runtime_replacement_classes=runtime_replacement_classes or set(),
            runtime_replacement_mixins=runtime_replacement_mixins or {},
            runtime_replacement_methods=runtime_replacement_methods or {},
        )

        self._registry = registry

        # Initialize specialized generators
        self._type_converter = TypeConverter(self._ctx, registry)
        self._expr_generator = ExpressionGenerator(self._ctx, self._type_converter, registry)
        self._stmt_generator = StatementGenerator(
            self._ctx, self._expr_generator, self._type_converter
        )
        self._func_generator = FunctionGenerator(
            self._ctx, self._expr_generator, self._stmt_generator, self._type_converter
        )
        self._def_generator = DefinitionGenerator(
            self._ctx, self._type_converter, self._expr_generator
        )
        self._import_generator = ImportGenerator(self._ctx)
        self._contract_generator = ContractGenerator(
            self._ctx, self._type_converter, self._expr_generator,
            self._func_generator, self._def_generator, registry
        )

    # =========================================================================
    # PUBLIC API
    # =========================================================================

    def generate(self, ast: SourceUnit) -> str:
        """Generate TypeScript code from the AST.

        Args:
            ast: The SourceUnit AST node

        Returns:
            The generated TypeScript code as a string
        """
        output = []

        # Reset context for this file
        self._ctx.reset_for_file()

        # Determine file type before generating (affects identifier prefixes)
        contract_name = ast.contracts[0].name if ast.contracts else ''
        self._determine_file_type(ast, contract_name)

        # Build qualified name cache
        self._ctx.build_qualified_name_cache(self._ctx.current_file_type)

        # Add header
        output.append('// Auto-generated by sol2ts transpiler')
        output.append('// Do not edit manually\n')

        # Generate imports (placeholder, will be filled later)
        import_placeholder_index = len(output)
        output.append('')

        # Generate enums first
        for enum in ast.enums:
            output.append(self._def_generator.generate_enum(enum))

        # Generate top-level constants
        for const in ast.constants:
            output.append(self._def_generator.generate_constant(const))

        # Generate structs
        for struct in ast.structs:
            output.append(self._def_generator.generate_struct(struct))

        # Generate contracts/interfaces
        for contract in ast.contracts:
            output.append(self._contract_generator.generate_contract(contract))

        # Insert imports at placeholder
        import_lines = self._import_generator.generate(self._ctx.current_file_type)
        output[import_placeholder_index] = import_lines

        return '\n'.join(output)

    # =========================================================================
    # BACKWARD COMPATIBILITY
    # =========================================================================

    # Expose some context properties for backward compatibility

    @property
    def indent_level(self) -> int:
        """Get the current indentation level."""
        return self._ctx.indent_level

    @indent_level.setter
    def indent_level(self, value: int):
        """Set the current indentation level."""
        self._ctx.indent_level = value

    @property
    def indent_str(self) -> str:
        """Get the indentation string."""
        return self._ctx.indent_str

    def indent(self) -> str:
        """Return the current indentation string."""
        return self._ctx.indent()

    @property
    def current_state_vars(self) -> Set[str]:
        """Get the current contract's state variables."""
        return self._ctx.current_state_vars

    @current_state_vars.setter
    def current_state_vars(self, value: Set[str]):
        self._ctx.current_state_vars = value

    @property
    def current_methods(self) -> Set[str]:
        """Get the current contract's methods."""
        return self._ctx.current_methods

    @current_methods.setter
    def current_methods(self, value: Set[str]):
        self._ctx.current_methods = value

    @property
    def var_types(self) -> Dict:
        """Get the variable types dictionary."""
        return self._ctx.var_types

    @var_types.setter
    def var_types(self, value: Dict):
        self._ctx.var_types = value

    @property
    def known_structs(self) -> Set[str]:
        """Get the set of known struct names."""
        return self._ctx.known_structs

    @property
    def known_enums(self) -> Set[str]:
        """Get the set of known enum names."""
        return self._ctx.known_enums

    @property
    def known_contracts(self) -> Set[str]:
        """Get the set of known contract names."""
        return self._ctx.known_contracts

    @property
    def known_interfaces(self) -> Set[str]:
        """Get the set of known interface names."""
        return self._ctx.known_interfaces

    def get_qualified_name(self, name: str) -> str:
        """Get the qualified name for a type."""
        return self._ctx.get_qualified_name(name)

    # Delegate to specialized generators for methods that might be called directly

    def generate_expression(self, expr) -> str:
        """Generate TypeScript expression (for backward compatibility)."""
        return self._expr_generator.generate(expr)

    def generate_statement(self, stmt) -> str:
        """Generate TypeScript statement (for backward compatibility)."""
        return self._stmt_generator.generate(stmt)

    def generate_function(self, func) -> str:
        """Generate TypeScript function (for backward compatibility)."""
        return self._func_generator.generate_function(func)

    def generate_struct(self, struct) -> str:
        """Generate TypeScript struct (for backward compatibility)."""
        return self._def_generator.generate_struct(struct)

    def generate_enum(self, enum) -> str:
        """Generate TypeScript enum (for backward compatibility)."""
        return self._def_generator.generate_enum(enum)

    def generate_contract(self, contract) -> str:
        """Generate TypeScript contract (for backward compatibility)."""
        return self._contract_generator.generate_contract(contract)

    def solidity_type_to_ts(self, type_name) -> str:
        """Convert Solidity type to TypeScript (for backward compatibility)."""
        return self._type_converter.solidity_type_to_ts(type_name)

    def default_value(self, ts_type: str) -> str:
        """Get default value for TypeScript type (for backward compatibility)."""
        return self._type_converter.default_value(ts_type)

    # =========================================================================
    # PRIVATE METHODS
    # =========================================================================

    def _determine_file_type(self, ast: SourceUnit, contract_name: str) -> None:
        """Determine the file type based on AST contents."""
        if ast.enums and not ast.contracts:
            self._ctx.current_file_type = 'Enums'
        elif ast.structs and not ast.contracts:
            self._ctx.current_file_type = 'Structs'
        elif ast.constants and not ast.contracts and not ast.structs:
            self._ctx.current_file_type = 'Constants'
        else:
            self._ctx.current_file_type = contract_name
